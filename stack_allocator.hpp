/* 
 * Copyright (C) 2014 Charles Salvia, 
 * Copyright (C) 2014 Hailoo, Inc.
 *
 * Distributed under the Eos Software License, Version 1.0
 * (http://www.eos.org/license1_0.txt)
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *	Description: Dynamic array for tree node child pointers (for eos::tree)
 * 
 * Author(s): Charles Salvia
 *
*/

#ifndef EOS_MEMORY_STACK_ALLOCATOR_HPP
#define EOS_MEMORY_STACK_ALLOCATOR_HPP

#include <functional>
#include <memory>

namespace eos {

template <class T, std::size_t N, class Allocator = std::allocator<T>>
class stack_allocator
{
	public:

	typedef typename std::allocator_traits<Allocator>::value_type value_type;
	typedef typename std::allocator_traits<Allocator>::pointer pointer;
	typedef typename std::allocator_traits<Allocator>::const_pointer const_pointer;
	typedef typename Allocator::reference reference;
	typedef typename Allocator::const_reference const_reference;
	typedef typename std::allocator_traits<Allocator>::size_type size_type;
	typedef typename std::allocator_traits<Allocator>::difference_type difference_type;

	typedef typename std::allocator_traits<Allocator>::const_void_pointer const_void_pointer;
	typedef Allocator allocator_type;
	
	public:

	explicit stack_allocator(const allocator_type& alloc = allocator_type()) 
		: m_allocator(alloc), m_begin(nullptr), m_end(nullptr), m_stack_pointer(nullptr)
	{ }

	explicit stack_allocator(pointer buffer, const allocator_type& alloc = allocator_type())
		: m_allocator(alloc), m_begin(buffer), m_end(buffer + N * sizeof(T)), 
			m_stack_pointer(buffer)
	{ }

	template <class U>
	stack_allocator(const stack_allocator<U, N, Allocator>& other)
		: m_allocator(other.m_allocator), m_begin(other.m_begin), m_end(other.m_end),
			m_stack_pointer(other.m_stack_pointer)
	{ }

	constexpr static size_type capacity()
	{
		return N;
	}

	pointer allocate(size_type n, const_void_pointer hint = const_void_pointer())
	{
		if (std::distance(m_stack_pointer, m_end) <= n)
		{
			pointer result = m_stack_pointer;
			m_stack_pointer += n;
			return result;
		}

		return m_allocator.allocate(n, hint);
	}

	void deallocate(value_type* p, size_type n)
	{
		if (pointer_to_internal_buffer(p))
		{
			m_stack_pointer -= n;
		}
		else m_allocator.deallocate(p, n);	
	}

	size_type max_size() const noexcept
	{
		return m_allocator.max_size();
	}

	template <class U, class... Args>
	void construct(U* p, Args&&... args)
	{
		m_allocator.construct(p, std::forward<Args>(args)...);
	}

	template <class U>
	void destroy(U* p)
	{
		m_allocator.destroy(p);
	}

	pointer address(reference x) const
	{
		if (pointer_to_internal_buffer(std::addressof(x)))
		{
			return std::addressof(x);
		}

		return m_allocator.address(x);
	}
	
	const_pointer address(const_reference x) const
	{
		if (pointer_to_internal_buffer(std::addressof(x)))
		{
			return std::addressof(x);
		}

		return m_allocator.address(x);
	}

	template <class U>
	struct rebind { typedef stack_allocator<U, N, allocator_type> other; };

	pointer buffer() const noexcept
	{
		return m_begin;
	}

	private:

	template <class U>
	bool pointer_to_internal_buffer(U* p) const
	{
		return (!(std::less<T*>()(p, m_begin)) && (std::less<T*>()(p, m_end)));
	}

	pointer m_begin;
	pointer m_end;
	pointer m_stack_pointer;
	allocator_type m_allocator;
};

template <class T1, std::size_t N, class Allocator, class T2>
bool operator == (const stack_allocator<T1, N, Allocator>& lhs, 
	const stack_allocator<T2, N, Allocator>& rhs) noexcept
{
	return lhs.buffer() == rhs.buffer();
}

template <class T1, std::size_t N, class Allocator, class T2>
bool operator != (const stack_allocator<T1, N, Allocator>& lhs, 
	const stack_allocator<T2, N, Allocator>& rhs) noexcept
{
	return !(lhs == rhs);
}

} // end namespace eos

#endif

